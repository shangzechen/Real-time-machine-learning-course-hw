import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import torch

dataset = pd.read_csv('/content/Housing.csv')
X = dataset.iloc[:, 1:].values
y = dataset.iloc[:, 0].values

print (X)
X.shape

print (y)
y.shape

from sklearn.compose  import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder

#encoder ->onehotencoder->指定操作的列数
#remainder ='passthrough', 除了被选中的列数以外都保持原样

ct=ColumnTransformer(transformers=[('encoder',OneHotEncoder(),[4,5,6,7,8,10,11])], remainder='passthrough')
X= ct.fit_transform(X)

print(X.dtype)
X

from sklearn.model_selection import train_test_split
X_train, X_validation, y_train, y_validation = train_test_split(X, y, test_size = 0.2, random_state = 0)


print(X_validation.shape)
X_validation

y_train = torch.tensor(y_train).unsqueeze(1) # <1>
print(y_train.shape)
y_train 

y_validation = torch.tensor(y_validation).unsqueeze(1)
print(y_validation .shape)
y_validation 

import torch.nn as nn

seq_model = nn.Sequential(
            nn.Linear(1, 8), # <1>
            nn.Tanh(),
            nn.Linear(8, 1)) # <2>
seq_model

def training_loop(n_epochs, optimizer, model, loss_fn, t_u_train, t_u_val,
                  t_c_train, t_c_val):
    for epoch in range(1, n_epochs + 1):
        t_p_train = model(t_u_train) # <1>
        loss_train = loss_fn(t_p_train, t_c_train)

        t_p_val = model(t_u_val) # <1>
        loss_val = loss_fn(t_p_val, t_c_val)
        
        optimizer.zero_grad()
        loss_train.backward() # <2>
        optimizer.step()

        if epoch == 200 or epoch % 200 == 0:
            print(f"Epoch {epoch}, Training loss {loss_train.item():.4f},"
                  f" Validation loss {loss_val.item():.4f}")
                  
import torch.optim as optim

optimizer = optim.SGD(seq_model.parameters(), lr=1e-3) # <1>

training_loop(
    n_epochs = 200, 
    optimizer = optimizer,
    model = seq_model,
    loss_fn = nn.MSELoss(),
    t_u_train = X_train,
    t_u_val = X_validation, 
    t_c_train = y_train,
    t_c_val = y_validation)
    
